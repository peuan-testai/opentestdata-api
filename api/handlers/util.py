from werkzeug.exceptions import NotFound
from ..db.models import User, Datum, Test


def get_item(Klass, name='obj', param_name='id', filter_key='id'):
    """
    Abstract decorator that finds an object by a filter and throws if it can't

    - Klass is the model class to use
    - name is the kwarg that the wrapped method will receive this object as
    - param_name is the API url parameter where we find the filter restriction
    - filter_key is the column name to use for the filter

    Example:
    @get_item(User, name='user', param_name='id', filter_key='id')
    def handler_method(user):
        # now we can do things with 'user' knowing it exists
        pass

    This decorator should probably remain abstract; see below for how we use it
    to make a more ergonomic @get_user decorator
    """

    def _get_item(func):
        def wrapper(*args, **kwargs):
            if filter_key not in kwargs:
                raise Exception('Guarded handler for "%s" but it was not in params' % filter_key)

            filter_kwargs = {}
            filter_kwargs[filter_key] = kwargs[param_name]
            obj = Klass.query.filter_by(**filter_kwargs).first()

            if obj is None:
                raise NotFound('Could not find %s with %s %s' % (name, filter_key, kwargs[param_name]))

            del kwargs[param_name]
            kwargs[name] = obj
            return func(*args, **kwargs)
        return wrapper
    return _get_item


def get_user(param_name='id', filter_key='id'):
    return get_item(User, 'user', param_name, filter_key)


def get_datum(param_name='id', filter_key='id'):
    return get_item(Datum, 'datum', param_name, filter_key)


def get_test(param_name='id', filter_key='id'):
    return get_item(Test, 'test', param_name, filter_key)
