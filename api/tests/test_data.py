import json
import pytest

from ..db.models import Datum
from .utils import make_datum


def test_can_create_datum(client, user, datum_dict):
    assert len(user.data) == 0
    resp = client.post('/data', headers=user.auth_headers, json=datum_dict)
    resp_data = dict(
        **datum_dict,
        user_id=user.id
    )
    assert 'created_at' in resp
    assert 'id' in resp
    del resp['created_at']
    del resp['id']
    assert resp == resp_data
    assert len(user.data) == 1


def test_can_create_object_datum(client, user):
    child_datum_1 = make_datum()
    child_datum_2 = make_datum()
    child_datum_3 = make_datum()
    value = {'foo': child_datum_1.id, 'bar': child_datum_2.id, 'baz': child_datum_3.id}
    datum_dict = dict(name='compound datum', type='OBJ', value=json.dumps(value))
    resp = client.post('/data', headers=user.auth_headers, json=datum_dict)
    datum = Datum.query.filter_by(id=resp['id']).first()
    children = map(lambda cd: cd.datum, datum.children)
    assert set(children) == set([child_datum_1, child_datum_2, child_datum_3])
    assert resp['value']['foo'] == child_datum_1.to_obj(whos_asking=user)
    assert resp['value']['bar'] == child_datum_2.to_obj(whos_asking=user)
    assert resp['value']['baz'] == child_datum_3.to_obj(whos_asking=user)


def test_create_datum_requires_login(client, datum_dict):
    resp = client.post('/data', json=datum_dict, raw=True).get_json()
    assert resp['status'] == 401
    assert 'authorization' in resp['detail']


def test_cant_create_datum_without_required_fields(client, user, datum_dict):
    req_fields = ['name', 'type', 'value']
    for req_field in req_fields:
        bad_input = dict(**datum_dict)
        del bad_input[req_field]
        resp = client.post('/data', headers=user.auth_headers, json=bad_input, raw=True).get_json()
        assert resp['status'] == 400
        assert req_field in resp['detail']
    assert user.data == []


def test_cant_create_datum_with_extra_fields(client, user, datum_dict):
    bad_input = dict(**datum_dict)
    bad_input['extra'] = 'foo'
    resp = client.post('/data', headers=user.auth_headers, json=bad_input, raw=True).get_json()
    assert resp['status'] == 400
    assert 'extra' in resp['detail']


def test_cant_create_datum_with_bad_input(client, user, datum_dict):
    bad_input = dict(**datum_dict)
    bad_input['type'] = 'STRRR'
    resp = client.post('/data', headers=user.auth_headers, json=bad_input, raw=True).get_json()
    assert resp['status'] == 400
    assert 'STR' in resp['detail']


def test_cant_create_datum_that_already_exists(client, user, datum_dict):
    assert len(user.data) == 0
    datum = client.post('/data', headers=user.auth_headers, json=datum_dict)
    assert len(user.data) == 1
    new_dict = dict(**datum_dict)
    new_dict['name'] = 'a new name'
    resp = client.post('/data', headers=user.auth_headers, json=new_dict, raw=True).get_json()
    assert resp['status'] == 400
    assert 'already' in resp['detail']
    assert f'id {datum["id"]}' in resp['detail']
    assert len(user.data) == 1


def test_cant_create_object_datum_that_already_exists(client, user):
    # make the first copy
    child_datum_1 = make_datum()
    child_datum_2 = make_datum()
    child_datum_3 = make_datum()
    value = {'foo': child_datum_1.id, 'bar': child_datum_2.id, 'baz': child_datum_3.id}
    datum_dict = dict(name='compound datum', type='OBJ', value=json.dumps(value))
    resp1 = client.post('/data', headers=user.auth_headers, json=datum_dict)

    # make the second copy, with different names but same child data
    value = {'oof': child_datum_1.id, 'rab': child_datum_2.id, 'zab': child_datum_3.id}
    datum_dict = dict(name='mutad dnuopmoc', type='OBJ', value=json.dumps(value))
    resp2 = client.post('/data', headers=user.auth_headers, json=datum_dict, raw=True).get_json()
    assert resp2['status'] == 400
    assert str(resp1['id']) in resp2['detail']


def test_cant_create_object_datum_with_duplicate_children(client, user):
    child_datum_1 = make_datum()
    child_datum_2 = make_datum()
    value = {'foo': child_datum_1.id, 'bar': child_datum_2.id, 'baz': child_datum_2.id}
    datum_dict = dict(name='compound datum', type='OBJ', value=json.dumps(value))
    resp = client.post('/data', headers=user.auth_headers, json=datum_dict, raw=True).get_json()
    assert resp['status'] == 400
    assert 'duplicate' in resp['detail']


def test_can_update_datum(client, datum):
    new_datum_dict = dict(name='new datum', type='NUM', value='500')
    updated_datum = client.post(f'/data/{datum.id}', headers=datum.author.auth_headers,
                                json=new_datum_dict)
    new_datum_dict['id'] = datum.id
    new_datum_dict['user_id'] = datum.author.id
    del updated_datum['created_at']
    assert updated_datum == new_datum_dict


def test_cant_update_datum_thats_not_yours(client, datum, user, datum_dict):
    assert datum.name != datum_dict['name']
    resp = client.post(f'/data/{datum.id}', headers=user.auth_headers,
                       json=datum_dict, raw=True).get_json()
    assert resp['status'] == 401
    assert 'name' not in resp


def test_cant_update_datum_with_bad_input(client, datum):
    new_datum_dict = dict(name='new datum', type='STRRR', value='500')
    resp = client.post(f'/data/{datum.id}', headers=datum.author.auth_headers, json=new_datum_dict, raw=True).get_json()
    assert resp['status'] == 400
    assert 'STR' in resp['detail']


def test_can_update_datum_thats_not_yours_if_admin(client, datum, admin_user, datum_dict):
    new_datum_dict = dict(name='new datum from admin', type='NUM', value='501')
    updated_datum = client.post(f'/data/{datum.id}', headers=admin_user.auth_headers,
                                json=new_datum_dict)
    new_datum_dict['id'] = datum.id
    new_datum_dict['user_id'] = datum.author.id
    del updated_datum['created_at']
    assert updated_datum == new_datum_dict


@pytest.mark.skip(reason="TODO")
def test_cant_update_datum_with_cyclical_children(client, user):
    pass


def test_can_get_datum_details(client, datum, user):
    resp = client.get(f'/data/{datum.id}', headers=user.auth_headers)
    expected = datum.to_obj(whos_asking=user)
    del expected['created_at']
    del resp['created_at']
    assert resp == expected


def test_cant_get_datum_that_doesnt_exist(client, user):
    resp = client.get(f'/data/999999', headers=user.auth_headers, raw=True).get_json()
    assert resp['status'] == 404
