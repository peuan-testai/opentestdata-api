import json

from enum import Enum
from .. import db
from . import ChildDatum
from .base import BaseModel


class DatumType(Enum):
    NULL = 'NULL'
    BOOLEAN = 'BOOL'
    NUMBER = 'NUM'
    STRING = 'STR'
    OBJECT = 'OBJ'


def parse_object_json(obj_str, parent=None):
    obj = json.loads(obj_str)
    data = {}

    if len(obj.values()) != len(set(obj.values())):
        raise Exception('You have a duplicate child object; you can only '
                        'include a child object once per parent object')

    for key in obj.keys():
        if type(obj[key]) != int:
            raise Exception(f'JSON object key {key} was not an integer datum id')

        data[key] = Datum.query.filter_by(id=obj[key]).first()
        if data[key] is None:
            raise Exception(f'Datum id {obj[key]} referenced with object key {key} did not exist')

    if parent is not None and object_is_cyclical(parent, data):
        raise Exception('Cannot create a datum with cyclical child references')

    return data


def object_is_cyclical(parent, data):
    for child_datum in data.values():
        if parent.id == child_datum.id:
            return True
        if child_datum.type == DatumType.OBJECT:
            return object_is_cyclical(parent, child_datum.object_value())
    return False


class Datum(BaseModel):
    __tablename__ = 'data'

    # fields
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    name = db.Column(db.String(length=100), nullable=False)
    type = db.Column(db.Enum(DatumType), default=DatumType.STRING, nullable=False)
    value = db.Column(db.String(length=1024), nullable=True)

    private_fields = []
    # type is not included in public_fields because as an enum we must unwrap
    # it in 'to_obj'
    public_fields = ['name', 'value', 'user_id', 'created_at']

    # relationships
    author = db.relationship('User', back_populates='data', foreign_keys=[user_id])
    children = db.relationship('ChildDatum', back_populates='parent', uselist=True, foreign_keys=lambda: ChildDatum.parent_id)
    included_in = db.relationship('ChildDatum', back_populates='datum', uselist=True, foreign_keys=lambda: ChildDatum.datum_id)
    # TODO tags many-many via join table

    def __repr__(self):
        if self.type == DatumType.OBJECT:
            children_repr = map(lambda cd: f'{cd.name}: {cd.datum.__repr__()}', self.children)
            children_repr = "\n    ".join(children_repr)
            return f"<Datum #{self.id} '{self.name}' (by {self.author.username})\n    {children_repr}\n>"
        else:
            return (f"<Datum #{self.id} '{self.name}' "
                    f"[{self.type}: {self.value[:20]}] (by {self.author.username})>")

    def object_value(self):
        if self.type != DatumType.OBJECT:
            return self.value

        value = {}
        for child in self.children:
            value[child.name] = child.datum

        return value

    def to_obj(self, *args, **kwargs):
        obj = super().to_obj(*args, **kwargs)
        obj['type'] = self.type.value
        if self.type == DatumType.OBJECT:
            obj['value'] = {}
            for child in self.children:
                obj['value'][child.name] = child.datum.to_obj(**kwargs)
        return obj

    def update(self, **kwargs):
        if kwargs.get('name') is not None:
            self.name = kwargs['name']
        if kwargs.get('type') is not None:
            self.type = kwargs['type']
        if kwargs.get('value') is not None:
            value = kwargs['value']
            if self.type == DatumType.OBJECT:
                value = parse_object_json(value, parent=self)
            Datum.ensure_uniqueness(value, self.type)

            if self.type != DatumType.OBJECT:
                self.value = value
            else:
                # we have an object type, which means we may need to modify, add,
                # or delete ChildDatum rows corresponding to the child data. The
                # simplest thing is just to delete them all and re-add them all,
                # so do that unless and until it becomes an issue.
                self.remove_children(commit=False)
                self.add_children(value, commit=False)

            db.session.commit()

    def remove_children(self, commit=True):
        for child in self.children:
            db.session.delete(child)
        if commit:
            db.session.commit()

    def add_children(self, value, commit=True):
        for name, child_datum in value.items():
            child_datum_obj = ChildDatum(parent=self, name=name, datum=child_datum)
            db.session.add(child_datum_obj)

        if commit:
            db.session.commit()

    @staticmethod
    def find(value, type):
        if type == DatumType.OBJECT:
            # in this case, value is a map of keys to datum objects.
            # we want to find any other datum whose type is object and which
            # consists of the same child data. First we get the list of child
            # ids to match against.
            child_ids = list(map(lambda child: child.id, value.values()))

            # then we get the parent id of any parent attached to any datum
            # child that lists one of the child ids, whose count is the same as
            # the count of child ids (so we know it has all of them)
            qs = (f'SELECT ANY_VALUE(parent_id), COUNT(parent_id) AS count '
                 f'FROM {ChildDatum.__tablename__} WHERE datum_id IN '
                 f':child_ids GROUP BY parent_id HAVING count = :count')
            result = db.session.execute(qs, {'child_ids': child_ids, 'count': len(child_ids)}).first()
            if result is None:
                return None

            # if we get here, then the parent id will be the first value in the
            # returned row
            return Datum.query.filter_by(id=result[0]).first()

        return Datum.query.filter_by(value=value, type=type).first()

    @staticmethod
    def create(*args, **kwargs):
        value = kwargs['value']
        type = kwargs['type']
        if type == DatumType.OBJECT:
            value = parse_object_json(value)
        Datum.ensure_uniqueness(value, type)
        if type == DatumType.OBJECT:
            kwargs['value'] = None
            datum = Datum(**kwargs)
            db.session.add(datum)
            db.session.flush()
            datum.add_children(value, commit=False)
        else:
            datum = Datum(**kwargs)
            db.session.add(datum)

        db.session.commit()

        return datum

    @staticmethod
    def ensure_uniqueness(value, type):
        old_datum = Datum.find(value, type)
        if old_datum is not None:
            err = ('The combination of value and type must be unique '
                   'and datum with id %s already contains these values' %
                   old_datum.id)
            raise Exception(err)
