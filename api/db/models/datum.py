from enum import Enum
from .. import db
from .base import BaseModel


class DatumType(Enum):
    NULL = 'NULL'
    BOOLEAN = 'BOOL'
    NUMBER = 'NUM'
    STRING = 'STR'


class Datum(BaseModel):
    __tablename__ = 'data'

    # fields
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    name = db.Column(db.String(length=100), nullable=False)
    type = db.Column(db.Enum(DatumType), default=DatumType.STRING, nullable=False)
    value = db.Column(db.String(length=1024), nullable=False)

    private_fields = []
    # type is not included in public_fields because as an enum we must unwrap
    # it in 'to_obj'
    public_fields = ['name', 'value', 'user_id', 'created_at']

    # relationships
    author = db.relationship('User', back_populates='data', foreign_keys=[user_id])
    # TODO users = db.relationship('User', back_populates='data_used') via join table
    # TODO collections = db.relationship('Collection', back_populates='data') via join table
    # TODO tags many-many via join table

    def __repr__(self):
        return (
            "<Datum '%s' [%s: %s] (by %s)>" %
            (self.name, self.type, self.value[:20], self.author.username)
        )

    def to_obj(self, *args, **kwargs):
        obj = super().to_obj(*args, **kwargs)
        obj['type'] = self.type.value
        return obj

    @staticmethod
    def find(value, type):
        return Datum.query.filter_by(value=value, type=type).first()

    @staticmethod
    def create(*args, **kwargs):
        old_datum = Datum.find(kwargs['value'], kwargs['type'])
        if old_datum is not None:
            err = ('The combination of value and type must be unique '
                   'and datum with id %s already contains these values' %
                   old_datum.id)
            raise Exception(err)

        datum = Datum(**kwargs)
        db.session.add(datum)
        db.session.commit()

        return datum
