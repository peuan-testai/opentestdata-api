import pdb
from .. import db
from . import TestDatum, Datum, Disposition
from .base import BaseModel


class Test(BaseModel):
    __tablename__ = 'tests'

    # fields
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    name = db.Column(db.String(length=160), nullable=False)

    private_fields = []
    # data is added manually in to_obj
    public_fields = ['name', 'user_id', 'created_at']

    # relationships
    author = db.relationship('User', back_populates='tests', foreign_keys=[user_id])
    data = db.relationship('TestDatum', back_populates='test', uselist=True, foreign_keys=lambda: TestDatum.test_id)

    def __repr__(self):
        data_repr = list(map(lambda td: f'{td.label}: {td.datum.__repr__()}', self.data))
        return (f"<Test #{self.id} '{self.name}' ({self.author.username})"
                f"\n   {data_repr}\n>")

    def to_obj(self, *args, **kwargs):
        obj = super().to_obj(*args, **kwargs)
        obj['data'] = {}
        for td in self.data:
            obj['data'][td.label] = td.datum.to_obj(*args, **kwargs)
            obj['data'][td.label]['disposition'] = td.disposition.value
        return obj

    def add_datum(self, label, disposition, datum):
        # TODO see if we want piecemeal addition
        pass

    def remove_datum(self, datum):
        # TODO see if we want piecemeal deletion
        pass

    def update(self, *args, **kwargs):
        # TODO share code with create to ensure uniqueness etc
        pass

    @staticmethod
    def ensure_uniqueness(data):
        # TODO ensure uniqueness of test based on list of labels, data, dispositions
        pass

    @staticmethod
    def create(*args, **kwargs):
        # import pdb; pdb.set_trace()
        if len(kwargs.get('data', [])) == 0:
            raise Exception('Cannot create test without test data')

        data = kwargs['data']
        labels = list(map(lambda d: d['label'], data))
        if len(labels) != len(set(labels)):
            raise Exception('You have a duplicate test data label. You can only '
                            'use each label once per test')

        def to_test_datum(data_obj):
            id = data_obj['datum_id']
            datum = Datum.query.filter_by(id=id).first()
            if datum is None:
                raise Exception(f'You referred to datum with id "{id}" but it '
                                f'does not exist')
            return {
                'label': data_obj['label'],
                'disposition': Disposition(data_obj['disposition']),
                'datum': datum
            }

        data = list(map(to_test_datum, data))

        Test.ensure_uniqueness(data)

        del kwargs['data']
        test = Test(**kwargs)
        db.session.add(test)
        db.session.flush()
        for td_data in data:
            td = TestDatum(test_id=test.id, label=td_data['label'],
                           disposition=td_data['disposition'], datum=td_data['datum'])
            db.session.add(td)
        db.session.commit()
        return test
