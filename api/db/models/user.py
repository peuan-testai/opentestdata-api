from werkzeug.security import generate_password_hash, check_password_hash
from .. import db
from .base import BaseModel
from . import EmailConfirmationToken
from sqlalchemy import exc
from libgravatar import Gravatar


# TODO host a default no-avatar image
DEFAULT_AV_URL = 'https://example.com/image.png'


class User(BaseModel):
    __tablename__ = 'users'

    # fields
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(128))
    bio = db.Column(db.String(220), nullable=False, default="")
    has_avatar = db.Column(db.Boolean(), default=False)
    # TODO if has_avatar is false, maybe we cache the gravatar image url?
    is_admin = db.Column(db.Boolean(), default=False)
    is_email_confirmed = db.Column(db.Boolean(), default=False)

    private_fields = ['is_admin', 'is_email_confirmed', 'created_at', 'updated_at']
    public_fields = ['username', 'avatar_url', 'bio']

    # relationships
    ec_token = db.relationship('EmailConfirmationToken', back_populates='user',
                               uselist=False)
    data = db.relationship('Datum', back_populates='author', uselist=True)
    actions = db.relationship('Action', back_populates='user', uselist=True)

    def __repr__(self):
        return '<User %s>' % self.username

    @property
    def avatar_url(self):
        if self.has_avatar:
            # TODO return stored uploaded avatar
            return 'https://example.com/image.png'

        # otherwise return a gravatar url
        av = Gravatar(self.email)
        return av.get_image(size=200, default=DEFAULT_AV_URL,
                            filetype_extension=True, use_ssl=True)

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

    def has_access_to_field(self, user, field):
        # users always have access to their own data
        if user.id == self.id:
            return True

        return False

    def to_obj(self, *args, **kwargs):
        obj = super().to_obj(*args, **kwargs)
        obj['data'] = list(map(lambda d: d.to_obj(*args, **kwargs), self.data))
        return obj

    def update_email(self, email, commit=False):
        if self.ec_token:
            db.session.delete(self.ec_token)
        token = EmailConfirmationToken()
        token.generate_token()
        self.email = email
        self.is_email_confirmed = False
        self.ec_token = token
        if commit:
            db.session.commit()

    @staticmethod
    def create(username, email, password, bio, is_admin=False):
        # TODO add avatar upload here?
        token = EmailConfirmationToken()
        token.generate_token()
        user = User(username=username, email=email, is_admin=is_admin,
                    ec_token=token, bio=bio)
        user.set_password(password)
        db.session.add(user)
        db.session.add(token)
        try:
            db.session.commit()
        except exc.IntegrityError as e:
            db.session.rollback()
            raise e

        # TODO email confirmation process should actually send an e-mail at this point!
        return user
